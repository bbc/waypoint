= Waypoint

Waypoint is a toolset for recording trails between waypoints by
tagging tags against readers.

It is a early pre-alpha release of working code, as used at the Playful
Internet of Things Futures unconference on 7th November 2012


== What is it?

The core purpose of the toolset is a very specific task - to enable
attendees at an event to register their attendance at an session in
order to gain a customised transcript of their experience, enabling
ongoing conversations.

It is also used to demonstrate a handful of key technical points:

* That the data created by IP connected devices can be published and
  subscribed to

* Events generated by and controlling physical devices can be subscribed
  to

* That IP connected things can be controlled

* That it is possible to create manual "plumbing" connectors joining
  networked sensing things to networked controllable things.

This codebase does not (yet) represent these other key points

* That network connected things can be discovered on the network
* That network connected things can be introspected for their
  capabilities and interface description
* An end user toolset for exploring the network and wiring up things

However, the tag readers and actuation/visualisers can be wired up over
the network in a variety of ways, without modification of the things
beyond this basic interface.


== Where's the code?

There are 2 packages available from the playful internet website:

* http://www.playfulinternet.co.uk/code/

Additionally the codebase can be found from BBC R&D's github account
here:

* https://github.com/bbcrd/waypoint

(updates to this code will be pushed to github)


== What are the packages ?

There are two package available:

* python-waypoint_0.2.1_all.deb - This is a debian package, suitable
  for use with Ubuntu Linux, assuming some other dependencies have been
  installed

* waypoint-piotf.tar.gz - This is a snapshot of the development codebase
  as used for the Playful Internet of Things Futures event.


== What do the packages do?

When the debian package is installed, a unix service called waypointservice
is started which then runs in the background.

As soon as a tikitag or touchatag reader is plugged in, the waypoint
service starts logging tag readings. As soon as an arduino based actuator
is plugged in, when new tags are detected, the actuator is activated.
Furthermore, the actuator sends an ID to the waypoint service, which
is used to configure the logging of tags.

The code provides 3 network services:

* Port 1500 provides a duplicate continuous/live feed
  of the data logged locally.

* Port 1600 provides a control mechanism. Sending a message (followed
  by a carriage return) will trigger the actuator.

* Port 1700 provides a duplicate continuous/live feed of local
  actuation events

This means that any local RFID sensing device can be plumbed/connected
to any local control device.


== What do the packages /not/ do?

The code as provided includes a collator - which the tag readers can send
their data to. This collator and the code in the tag readers to send the
data is disabled in this code base. Additionally there are a couple of
basic analysers that operate on the data as collated, and operate in a
live/continuous fashion.

This package disables these two subsystems due to local network constraints
on the day for the Playful Internet of Things Workshop. However, the collator
is still included and installs into /usr/[local/]bin/waypoint_collator.
The basic/example analyser installs to waypoint_aggregate_analyser.

Additionally, it is possible to create a simple plumbing connector,
connecting the sensing devices to the collator, without changing the
code of either.

== How to write a plumbing connector.

A connector from tag reader to an actuator is a simple script of the
following form:

    from Kamaelia.Chassis.Pipeline import Pipeline
    from Kamaelia.Internet.TCPClient import TCPClient

    ReaderIP = "192.168.2.10"
    ActuatorIP = "192.168.2.20"

    Pipeline(
        TCPClient(ReaderIP, 1700),
        TCPClient(ActuatorIP, 1600),
    ).run()

Likewise, while the collator is disabled, if the collator (installed to
/usr/bin/waypoint_collator ) is running, then despite the tag reader
having the code disabled, a plumbing connector can also be created again
using a simple script of the following form:

    from Kamaelia.Chassis.Pipeline import Pipeline
    from Kamaelia.Internet.TCPClient import TCPClient

    ReaderIP = "192.168.2.10"
    CollatorIP= "192.168.2.20"
    CollationPort = 1800

    Pipeline(
        TCPClient(ReaderIP, 1500),
        TCPClient(CollatorIP, CollationPort),
    ).run()

The collator could then collate data, with live analysis of event data,
potentially with live feedback to attendees on session interest, etc.


== Who created it ?

The codebase was created in BBC Research and Development's North Lab by
the Internet Research and Future Services team in conjunction with Salford
University's Computer Network and Telecommunications Research department. 

This work has come about through the FIRM partnership, funded by EPSRC.
FIRM itself is a partnership between the BBC, Salford University, Lancaster
University, Goldsmiths University, NorthWest Vision & Media, BT, with
collaboration from MIT and Focus Innovation. 


== People

* Michael Sparks, BBC R&D - Development
* Vicky Spenger, BBC R&D - UX Design
* Jasmine Cox - Salford University - Actuator design and creation
* Prof Nigel Linge - Salford University - Consultation

